package server

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"
	"strconv"

	"github.com/kolide/osquery-golang/gen/osquery"
	"github.com/pkg/errors"
)

// TablePlugin is the minimum interface required to implement an osquery table
// as a plugin. Any value that implements this interface can be passed to
// NewTablePlugin to satisfy the OsqueryPlugin interface.
type TablePlugin interface {
	// TableName returns the name of the table the plugin implements.
	TableName() string

	// Columns returns the column definition of the table.
	Columns() interface{}

	// Generate returns the rows generated by the table. The ctx argument
	// should be checked for cancellation if the generation performs a
	// substantial amount of work. The queryContext argument provides the
	// deserialized JSON query context from osquery.
	Generate(ctx context.Context, queryContext QueryContext) ([]interface{}, error)
}

// NewTablePlugin takes a value that implements TablePlugin and wraps it with
// the appropriate methods to satisfy the OsqueryPlugin interface. Use this to
// easily create plugins implementing osquery tables.
func NewTablePlugin(plugin TablePlugin) *tablePluginImpl {
	return &tablePluginImpl{plugin}
}

type tablePluginImpl struct {
	plugin TablePlugin
}

// Ensure tablePluginImpl implements the OsqueryPlugin interface.
var _ OsqueryPlugin = (*tablePluginImpl)(nil)

func (t *tablePluginImpl) Name() string {
	return t.plugin.TableName()
}

func (t *tablePluginImpl) RegistryName() string {
	return "table"
}

// Get column name, prefer the struct tag "column", otherwise use
// the literal name of the field.
func columnNameFromStructField(field reflect.StructField) string {
	colName := field.Tag.Get("column")
	if colName == "" {
		colName = field.Name
	}

	return colName
}

// Retrieve the type of the field, following the pointer if
// necessary.
func columnTypeFromType(typ reflect.Type) columnType {
	fieldKind := typ.Kind()
	if fieldKind == reflect.Ptr {
		fieldKind = typ.Elem().Kind()
	}

	switch fieldKind {
	case reflect.Int:
		return columnTypeInteger
	case reflect.String:
		return columnTypeText
	case reflect.Float64:
		return columnTypeDouble
	default:
		return columnTypeUnknown
	}
}

func (t *tablePluginImpl) Routes() osquery.ExtensionPluginResponse {
	typ := reflect.TypeOf(t.plugin.Columns())
	if typ.Kind() != reflect.Struct {
		panic("column type must be struct for table " + t.plugin.TableName())
	}

	routes := []map[string]string{}
	for i := 0; i < typ.NumField(); i++ {
		colName := columnNameFromStructField(typ.Field(i))
		colType := columnTypeFromType(typ.Field(i).Type)

		routes = append(routes, map[string]string{
			"id":   "column",
			"name": colName,
			"type": string(colType),
			"op":   "0",
		})
	}

	return routes
}

func (t *tablePluginImpl) Ping() osquery.ExtensionStatus {
	return StatusOK
}

// Convert a slice of row structs into a slice of map[string]string.
func (t *tablePluginImpl) rowsToResponse(rows []interface{}) osquery.ExtensionPluginResponse {
	// Retrieve column names to use for map keys
	colNames := []string{}
	expectedType := reflect.TypeOf(t.plugin.Columns())
	for i := 0; i < expectedType.NumField(); i++ {
		colNames = append(colNames, columnNameFromStructField(expectedType.Field(i)))
	}

	response := osquery.ExtensionPluginResponse{}
	for _, row := range rows {
		if reflect.TypeOf(row) != expectedType {
			panic("table should only return rows of row type specified in Columns()")
		}

		val := reflect.ValueOf(row)
		rowMap := map[string]string{}
		for i, colName := range colNames {
			field := val.Field(i)

			if field.Kind() == reflect.Ptr && field.IsNil() {
				// Leave key unset when pointer value is nil
				continue
			}
			if field.Kind() == reflect.Ptr {
				// dereference pointer
				field = field.Elem()
			}

			rowMap[colName] = fmt.Sprintf("%v", field.Interface())
		}
		response = append(response, rowMap)
	}

	return response
}

func (t *tablePluginImpl) Call(ctx context.Context, request osquery.ExtensionPluginRequest) osquery.ExtensionResponse {
	switch request["action"] {
	case "generate":
		queryContext, err := parseQueryContext(request["context"])
		if err != nil {
			return osquery.ExtensionResponse{
				Status: &osquery.ExtensionStatus{
					Code:    1,
					Message: "error parsing context JSON: " + err.Error(),
				},
			}
		}

		rows, err := t.plugin.Generate(ctx, *queryContext)
		if err != nil {
			return osquery.ExtensionResponse{
				Status: &osquery.ExtensionStatus{
					Code:    1,
					Message: "error generating table: " + err.Error(),
				},
			}
		}

		return osquery.ExtensionResponse{
			Status:   &StatusOK,
			Response: t.rowsToResponse(rows),
		}

	case "columns":
		return osquery.ExtensionResponse{
			Status:   &StatusOK,
			Response: t.Routes(),
		}

	default:
		return osquery.ExtensionResponse{
			Status: &osquery.ExtensionStatus{
				Code:    1,
				Message: "unknown action: " + request["action"],
			},
		}
	}

}

func (t *tablePluginImpl) Shutdown() {}

// columnType is a strongly typed representation of the data type string for a
// column definition. The named constants should be used.
type columnType string

// The following column types are defined in osquery tables.h.
const (
	columnTypeText    columnType = "TEXT"
	columnTypeInteger            = "INTEGER"
	columnTypeBigInt             = "BIGINT"
	columnTypeDouble             = "DOUBLE"
	columnTypeUnknown            = "UNKNOWN"
)

// QueryContext contains the constraints from the WHERE clause of the query,
// that can optionally be used to optimize the table generation. Note that the
// osquery SQLite engine will perform the filtering with these constraints, so
// it is not mandatory that they be used in table generation.
type QueryContext struct {
	// Constraints is a map from column name to the details of the
	// constraints on that column.
	Constraints map[string]ConstraintList
}

// ConstraintList contains the details of the constraints for the given column.
type ConstraintList struct {
	Affinity    columnType
	Constraints []Constraint
}

// Constraint contains both an operator and an expression that are applied as
// constraints in the query.
type Constraint struct {
	Operator   Operator
	Expression string
}

// Operator is an enum of the osquery operators.
type Operator int

// The following operators are dfined in osquery tables.h.
const (
	OperatorEquals              Operator = 2
	OperatorGreaterThan                  = 4
	OperatorLessThanOrEquals             = 8
	OperatorLessThan                     = 16
	OperatorGreaterThanOrEquals          = 32
	OperatorMatch                        = 64
	OperatorLike                         = 65
	OperatorGlob                         = 66
	OperatorRegexp                       = 67
	OperatorUnique                       = 1
)

// The following types and functions exist for parsing of the queryContext
// JSON and are not made public.
type queryContextJSON struct {
	Constraints []constraintListJSON `json:"constraints"`
}

type constraintListJSON struct {
	Name     string          `json:"name"`
	Affinity string          `json:"affinity"`
	List     json.RawMessage `json:"list"`
}

func parseQueryContext(ctxJSON string) (*QueryContext, error) {
	var parsed queryContextJSON

	err := json.Unmarshal([]byte(ctxJSON), &parsed)
	if err != nil {
		return nil, errors.Wrap(err, "unmarshaling context JSON")
	}

	ctx := QueryContext{map[string]ConstraintList{}}
	for _, cList := range parsed.Constraints {
		constraints, err := parseConstraintList(cList.List)
		if err != nil {
			return nil, err
		}

		ctx.Constraints[cList.Name] = ConstraintList{
			Affinity:    columnType(cList.Affinity),
			Constraints: constraints,
		}
	}

	return &ctx, nil
}

func parseConstraintList(constraints json.RawMessage) ([]Constraint, error) {
	var str string
	err := json.Unmarshal(constraints, &str)
	if err == nil {
		// string indicates empty list
		return []Constraint{}, nil
	}

	var cList []map[string]string
	err = json.Unmarshal(constraints, &cList)
	if err != nil {
		// cannot do anything with other types
		return nil, errors.Errorf("unexpected context list: %s", string(constraints))
	}

	cl := []Constraint{}
	for _, c := range cList {
		opInt, err := strconv.Atoi(c["op"])
		if err != nil {
			return nil, errors.Errorf("parsing operator int: %s", c["op"])
		}

		cl = append(cl, Constraint{
			Operator:   Operator(opInt),
			Expression: c["expr"],
		})
	}
	return cl, nil
}
